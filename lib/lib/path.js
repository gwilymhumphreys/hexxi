// Generated by CoffeeScript 1.9.3
(function() {
  var HexUtils, MOVE_COST, Path, _,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('lodash');

  HexUtils = require('./hex_utils');

  MOVE_COST = 1;

  module.exports = Path = (function() {
    Path.MOVE_COST = MOVE_COST;

    function Path(map1, options) {
      this.map = map1;
      this._setValues = bind(this._setValues, this);
      this._tracePathToStart = bind(this._tracePathToStart, this);
      this._neighbours = bind(this._neighbours, this);
      this.findPath = bind(this.findPath, this);
      this.node = bind(this.node, this);
      this.prev = bind(this.prev, this);
      this.next = bind(this.next, this);
      this.reset = bind(this.reset, this);
      _.extend(this, options);
      this.reset();
    }

    Path.createMap = function(entities) {
      var current, entity, j, len, map, node, q, r;
      map = [];
      for (j = 0, len = entities.length; j < len; j++) {
        entity = entities[j];
        q = entity.q, r = entity.r;
        node = Path.prototype._toNode(entity);
        map[q] || (map[q] = []);
        if (current = map[q][r]) {
          node.traversable = current.traversable && entity.traversable;
        }
        map[q][r] = node;
      }
      return map;
    };

    Path.prototype.reset = function() {
      this.open = [];
      this.closed = {};
      this.path = [];
      return this.iter = 0;
    };

    Path.prototype.next = function() {
      ++this.iter;
      if (this.iter > this.path.length) {
        return this.iter = this.path.length;
      }
    };

    Path.prototype.prev = function() {
      --this.iter;
      if (this.iter < 0) {
        return this.iter = 0;
      }
    };

    Path.prototype.node = function() {
      return this.path[this.iter];
    };

    Path.prototype.hash = function(node) {
      return node.q + ", " + node.r;
    };

    Path.prototype.findPath = function(start, goal) {
      var closed_node, closing, j, len, neighbour, path, ref;
      if (!this.map) {
        throw new Error('Path::findPath requires a map to be supplied first');
      }
      start = this._toNode(start);
      this.goal = this._toNode(goal);
      this._setValues(start, null, goal);
      this.reset();
      this.open.push(start);
      while (this.open.length > 0) {
        closing = this.open.shift();
        if (HexUtils.equal(closing, this.goal)) {
          this.closed[this.hash(closing)] = closing;
          path = this._tracePathToStart(closing);
          return path;
        }
        if (!this.closed[this.hash(closing)]) {
          this.closed[this.hash(closing)] = closing;
          ref = this._neighbours(closing);
          for (j = 0, len = ref.length; j < len; j++) {
            neighbour = ref[j];
            neighbour = this._setValues(neighbour, closing, this.goal);
            if (closed_node = this.closed[this.hash(neighbour)]) {
              if ((closing.g + neighbour.cost) < closed_node.g) {
                this.closed[this.hash(neighbour)] = neighbour;
              }
            } else {
              this._insertSorted(neighbour, this.open);
            }
          }
        }
      }
    };

    Path.prototype._neighbours = function(node) {
      var adjacent, coord, dir, j, n, ref;
      adjacent = [];
      for (dir = j = 0; j <= 5; dir = ++j) {
        coord = HexUtils.neighbour(node, dir);
        if (n = (ref = this.map[coord.q]) != null ? ref[coord.r] : void 0) {
          if (n.traversable || (this.end_traversable && HexUtils.equal(n, this.goal))) {
            adjacent.push(this._toNode(n));
          }
        }
      }
      return adjacent;
    };

    Path.prototype._tracePathToStart = function(node) {
      var c, max, path;
      path = [];
      max = 10;
      c = 0;
      while (node) {
        if (++c > max) {
          return path;
        }
        path.push(node);
        node = node.parent;
      }
      return path;
    };

    Path.prototype._setValues = function(node, parent, goal) {
      node.parent = parent;
      node.cost || (node.cost = MOVE_COST);
      node.g = ((parent != null ? parent.g : void 0) || 0) + node.cost;
      node.h = HexUtils.distance(node, goal);
      node.f = node.g + node.h;
      return node;
    };

    Path.prototype._insertSorted = function(node, list) {
      var i, j, ref;
      if (!list.length) {
        list.push(node);
        return list;
      }
      for (i = j = 0, ref = list.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        if (node.f < list[i].f) {
          list.splice(i, 0, node);
          return list;
        }
      }
    };

    Path.prototype._toNode = function(obj) {
      var node;
      node = _.pick(obj, 'q', 'r', 'traversable');
      if (node.traversable == null) {
        node.traversable = true;
      }
      return node;
    };

    Path.prototype._inspect = function(node) {
      return node.q + ", " + node.r;
    };

    return Path;

  })();

}).call(this);
